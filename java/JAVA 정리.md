# JAVA 정리

자바에 대해서 한번 다시 정리 해보려고 만든 markdown  ~~짜릿해! 늘 새로워~~

# 목차



# 객체 지향 프로그래밍(OOP)

객체 지향 프로그래밍 (OOP : Object Oriented Programming)은 프로그램을 객체라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식이라고 한다.  

> 뭐 쉽게 말해서 객체(method와 변수)를 만들고 그것을 사용함으로 프로그램을 만드는 방식?이라고하면 될거 같은데



## 객체란?

객체(Object)란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말한다. 

쉽게 말해 

- 물리적으로 존재하는 물건 (ex 자동차, 자전거 등)
- 속성 (사람의 이름 ,나이, 자동차의 색상)
- 동작 (자동차의 엑셀, 정지)

같은 것들을 객체로 정의 할 수 있다.

여기서 속성은 필드 (field) 동작은 메소드 (method)라고 부른다.



## 객체 지향 프로그래밍의 특징

- 캡슐화 (Encapsulation)

  캡슐화란 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다. 외부 객체는 객체 내부의 구조를 알지 못하며 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있다.

  캡슐화하여 필드와 메소드를 보호하는 이유는 외부의 잘못된 사용으로 인해 객체가 손상되지 않도록 하는데 있다. 

  자바에서는 접근을 허용할지 아닌지를 결정하기 위해 접근제한자 (Access Modifier)를 사용한다.

- 상속 (Inheritance)

  객체 지향 프로그래밍에서 부모 역활의 상위 객체와 자식 역활의 하위 객체가 있다. 상위 객체는 자기가 가지고 있는 필드와 메소드를 하위 객체에게 물려주어 하위 객체가 사용할 수 있도록 해준다.

  상속은 상위 객체를 재사용해서 하위 객체를 쉽고 빨리 설계할 수 있도록 도와주고, 이미 잘 개발된 객체를 재사용해서 새로운 객체를 만들기 때문에 반복된 코드의 중복을 줄여준다.

- 다형성 (polymorphism)

  다형성은 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질을 말한다. 코드 측면에서 보면 다형성은 하나의 타입에 여러 객체를 대입함으로써 다양한 기능을 이용할 수 있도록 해준다. 자바는 다형성을 위해 부모 클래스 또는 인터페이스의 타입 변환을 허용한다. 부모 타입에는 모든 자식 객체가 대입될 수 있고, 인터페이스 타입에는 모든 구현 객체가 대입될 수 있다. 다형성의 효과로 객체는 부품화가 가능하다. 예를 들어 자동차를 설계할 때 타이어 인터페이스 타입을 적용했다면 이 인터페이스를 구현한 실제 타이어들은 어떤 것이든 상관없이 장착(대입)이 가능하다.

  >###  오버로딩과 오버라이딩
  >
  >기본적으로 자바의 다형성의 좋은 예로 오버로딩(Overloading), 오버라이딩(Overriding)이 있다.
  >
  >- 오버로딩(Overloading)  : 같은 메서드 이름, 다른 인자 목록에서 다수의 메서드를 중복 정의
  >- 오버라이딩(Overriding) : 같은 메서드 이름, 같은 인자 목록에서 상위 클래스의 메서드를 재정의
  >
  >```java
  >//Animal.java
  >public class Animal {
  > 
  >    public String name;
  > 
  >    public void showName() {
  >        System.out.printf("안녕 나는 %s야. 반갑다.\n", name);    
  >    }
  >}
  >
  >//Tiger.java
  >public class Tiger extends Animal {
  > 
  >    public String habitat;
  >     
  >    public void showHabitat(){
  >        System.out.printf("%s는 %s에 살아\n",name,habitat);
  >    }
  >     
  >    //오버라이딩
  >    public void showName(){
  >        System.out.println("오버라이딩!! 보안상 이름을 말할 수 없습니다.");
  >    }
  >     
  >    //오버로딩
  >    public void showName(String yourName){
  >        System.out.printf("오버로딩!! %s 안녕, 나는 %s라고 해\n",yourName, name);
  >    }
  >}
  >```
  >
  >그럼 도대체 왜 자바에서 다형성을 하는가?? 즉 왜 오버로딩과 오버라이딩을 해야하는가?
  >
  >==그 이유는 바로 코드 재사용성이 높아지기 때문이다.== 사용했던 코드를 다시 살짝만 바꿔서 목적과 용도에 맞게끔 설계하면 개발자의 편의성이 높아진다. 덩달아 유지보수도 높아진다. 또한, 객체지향 설계원칙에 부합한다. 사람이 사고하는 생각의 흐름처럼 자연스럽게 코드에도 적용할 수 있기 때문이다. 
  >
  >그리고 기능에 대해 용도와 목적에 맞게끔 커스터마이징할 수 있다.
  >
  >끝으로 정리하자면,
  >
  >==오버라이딩==은 부모클래스에서 상속받은 서브클래스 즉 자식클래스에서 부모클래스,즉 상위클래스에서 만들어진 메서드를 자신의 입맛대로 다시 재창조해서 사용하는 것을 말한다.
  >
  >==오버로딩==은 하나의 클래스 안에서 같은이름의 메서드를 사용하지만 각 메서드마다 다른 용도로 사용되며 그 결과물도 다르게 구현할 수 있게 만드는 개념인데 오버로딩이 가능하려면 메서드끼리 이름은 같지만 매개변수의 갯수나 데이터타입이 다르면 오버로딩이 적용되어 메서드 이름이 같아도 문법 에러가 나지않는다..
  >
  >---- 출처 : [Limky 삽질블로그](https://limkydev.tistory.com/116)



## 객체와 클래스

자바에서 객체라는 부품의 설계도를 클래스(class)라고 한다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다. 

- 클래스로부터 만들어진 객체를 해당 클래스의 인스턴스(instance)라고 한다. 
- 클래스로부터 객체를 만드는 과정을 인스턴스화라고 한다.
- 하나의 클래스로부터 여러 개의 인스턴스를 만들 수 있다.





## 클래스 선언

### 자바의 식별자 작성 규칙

클래스의 이름은 다른 클래스와 식별할 목적으로 사용됨으로 자바의 식별자 작성 규칙에 따라서 만들어야 한다. ~~이젠 너무 당연한거라 이걸 왜 적었지....~~

| 번호 | 작성 규칙                                 | 예             |
| ---- | ----------------------------------------- | -------------- |
| 1    | 하나 이상의 문자로 이루어져야 한다.       | Car, SportsCar |
| 2    | 첫 번째 글자는 숫자가 올 수 없다.         | Car, 3Car(X)   |
| 3    | '$', '_' 외의 특수 문자는 사용할 수 없다. | @Car(X)        |
| 4    | 자바 키워드는 사용할 수 없다.             | int(X), for(X) |





## 객체 생성과 클래스 변수

클래스로부터 객체를 생성하는 방법은 다음과 같이 new 연산자를 사용한다.

```java
new 클래스();
클래스 변수 = new 클래스();
```

new는 클래스로부터 객체를 생성시키는 연산자이다. new 연산자 뒤에는 생성자가 오는데, 생성자는 클래스() 형태를 가지고 있다. new 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다.

- 해당 객체의 메모리 내에서 생성된 위치를 모르면 객체를 사용할 수 없다. 그래서 new 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴하도록 되어 있다.
- new 연산자를 사용한 만큼 객체가 메모리에 생성된다.





## 클래스의 구성 멤버

### 필드 (Field)

객체의 데이터가 저장되는 곳

필드는 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳이다. 선언 형태는 변수(variable)와 비슷하지만, 필드를 변수라고 부르지 않는다. 변수는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 실행 종료되면 자동 소멸된다. 하지만 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.



### 생성자

생성자는 new 연산자로 호출된다. 생성자의 역활은 객체 생성 시 초기화를 담당한다. 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 한다. 생성자는 메소드와 비슷하지만, 클래스 이름으로 되어 있고 리턴 타입이 없다.



### 메소드

메소드는 객체의 동작에 해당한다. C언어의 함수에 해당



## 인스턴스 멤버와 this

인스턴스(instance) 멤버란 객체 (인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부른다. 인스턴스 필드와 메소드는 객체에 소속된 멤버이기 때문에 객체 없이는 사용할 수 없다. 

```java
public class Car{
    // 필드
    int gas;
    
    // 메소드
    void setSpeed(int speed){
        ...
    }
}

```

인스턴스 필드 gas는 객체마다 따로 존재하고, 인스턴스 메소드 setSpeed()는 객체마다 존재하지 않고 메소드 영역에 저장되고 공유된다.

객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 맴버에 접근하기 위해 this를 사용할 수 있다. 객체 자신을 "this"라고 한다.

this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용된다.





## 정적 멤버와 static

정적(static)은 '고정된'이란 의미를 가지고 있다.정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말한다.

이들은 정적 필드, 정적 메소드라고 부르고, 정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 맴버라고도 한다.



### 정적 멤버 선언

정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 대 클래스별로 관리된다. 따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다.

> main문이 public static void main()인 이유가 이거다. 현재 메인 문이 있는 클래스를 인스턴스화가 되어 있지 않기때문이다. 
>
> 그리고 메인문이 있는 클래스에서 메소드를 생성시 static을 붙여줘야한다. 이 또한 위와 같은 이유 이다. 반대로 생성자로 즉 인스턴스로 만들어 해당 메소드를 사용할시에는 static은 필요없다.
>
> 이해를 쉽게 하자면 객체를 생성하지 않았으니 해당 객체는 설계도만 존재하고 아직 만들지 않은것이다. 그렇기 때문에 사용할 수 없다. 하지만 static을 붙여주면 따로 만들어 놓으라는  명령과 같다고 생각할 수 있다. <span style="color:gray">더 이해하기 힘든가? </span>
>
> 그리고 static은 인스턴스와 달리 정적으로 계속 존재한다는 점을 유희해야한다. 인스턴스의 데이터는 객체가 없어지거나 하면 없어지지만, static의 데이터는 프로그램의 종료까지 존재한다. 









## 싱글톤 (Singleton)

전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다. 단 하나만 생성된다고 해서 이 객체를 싱글톤(Singleton)이라고 하고, 이러한 패턴을 싱글톤패턴이라고 한다.

싱글톤을 만들려면 클래스 외부에서 new 연산자로 생성자를 호출할 수 없도록 막아야한다.  생성자를 호출한 만큼 객체가 생성되기 때문이다. 

생성자를 외부에서 호출할 수 없도록 하려면 생성자 앞에 private 접근 제한자를 붙여주면 된다.  그리고 자신의 타입인 정적 필드를 하나 선언하고 자신의 객체를 생성해 초기화한다.  참고로 클래스 내부에서는 new 연산자로 호출이 가능하다.

```java
// 싱글톤 코드
public class SingletonCase{
    //정적 필드
    private static SingletonCase singletonCase = new SingletonCase();
    
    //생성자
    private SingletonCase(){
        // 생성에 필요한 코드
    }
    
    //정적 메소드
    static SingletonCase getInstance(){
        return singletonCase;
    }
}
```

static으로 객체를 생성하고, 객체를 호출하는 방법은 getInstance()로만 가능하다. 이렇게 함으로써 싱글톤을 유지한다.

```java
SingletonCase singleTonObject1 = SingletonCase.getInstance();
SingletonCase singleTonObject2 = SingletonCase.getInstance();

```

getIncetance() 메소드는 단 하나의 객체만 리턴하기 때문에 아래 코드에서 변수1과 1변수2는 동일한 객체를 참조한다.

```java
public class Singleton{
    private static Singleton singleton = new Singleton();
    
    private Singleton9(){}
    
    static Singleton getInstance(){
        return singleton;
    }
}

public class SingletonExample{
    public static void main(String[] args){
        /*
        Singleton obj1 = new Singleton();// 컴파일 에러
        Singleton obj2 = new Singleton();// 컴파일 에러
        */
        Singleton obj1 = Singleton.getIncetance();
        Singleton obj2 = Singleton.getIncetance();
        if(obj1 == obj2){
            System.out.println("Object is equal");
        }else{
            System.out.println("Object is not equal");
        }
    }
}
// 해당 결과 = > "Object is equal"


```



## final 필드와 상수

### final 필드

final의 의미는 최종적이란 뜻을 가지고 있다.

## 참조

- [이것이 자바다  (한빛 미디어, 신용권)](http://www.hanbit.co.kr/store/education/edu_view.html?p_code=C5815590736)
- [Limky 삽질블로그](https://limkydev.tistory.com/116)

