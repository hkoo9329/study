

# 스프링 부트 정리 (스프링 부트 시작하기 책 정리글)

# 목차

- 2장
  - [파일구조의 의미](#파일구조의-의미)
  - [어노테이션 설명](#어노테이션-설명)
    - @RestController
    - @RequestMapping
    - @SpringBootApplication
  - [SampleApplication 클래스](#SampleApplication-클래스)
    - @SpringBootApplication
      - @EnableAutoConfiguration
      - @ComponentScan
      - @Configuration
- 3장
  - [스프링 프레임워크란?](#스프링-프레임워크란?)
  - [MVC 패턴 및 스프링 MVC](#MVC-패턴-및-스프링-MVC)
    - 스프링 웹 MVC의 구조
    - 일반적으로 사용하는 스프링 MVC의 구조
  - [MyBatis](#MyBatis)
    - MyBatis란?
- 4장
  - [Lombok 이란?](#Lombok-이란?)
  - [Service 인터페이스와 ServiceImpl 클래스를 분리](#Service-인터페이스와-ServiceImpl-클래스를-분리)
- 5장
  - [Logback 사용하기 (slf4j)](#Logback-사용하기-(slf4j))
  - [인터셉터](#인터셉터)
  - [AOP](#AOP)

# 2장

## 파일구조의 의미

| 프로젝트의 주요 파일 및 구조      | 의미                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| src/main/java                     | 자바 소스 디렉터리                                           |
| SampleApplication.class           | 애플리케이션을 시작할 수 있는 main 메서드가 존재하는 스프링 구성 메인 클래스 |
| templates                         | 스프링 부트에서 사용 가능한 여러 가지 뷰 탬플릿(Thymeleaf, Velocity, FreeMarker 등등 ) 파일 위치 |
| static                            | 스타일 시트, 자바스크립트, 이미지 등의 정적 리소스 디렉터리  |
| application.properties(or yml)    | 애플리케이션 및 스프링의 설정 등에서 사용할 여러 가지 프로퍼티(property) 정의 |
| Project and External Dependencies | 그레이들 또는 메이븐에서 명시한 프로젝트의 필수 라이브러리 모음 |
| src                               | JSP 등 리소스 디렉터리                                       |
| build.gradel Or pom.xml           | 빌드 명세, 프로젝트에 필요한 라이브러리 관리, 빌드 및 배포 설정 |





## 어노테이션 설명

### @RestController

- 어노테이션을 이용하여 해당 클래스가 REST 컨트롤러 기능을 수행하도록 한다.

### @RequestMapping

- 어노테이션은 해당 메서드를 실행할 수 있는 주소를 설정한다. 

  ```java
  @RequestMapping("/home")
  public String hello(){
      return "home";
  }
  ```

- 위의 코드에서 "/home"이라는 주소를 입력했다. 이는 즉 url에서 home라는 주소의 호출은 이 메소드 (class에도 @RequestMapping을 적용할 수 있음)를 실행한다는 의미이다.

### [@SpringBootApplication](#@SpringBootApplication)





## SampleApplication 클래스

- SampleApllication 클래스(스프링 실행 클래스)는 스프링 부트 애플리케이션의 구성과 실행을 담당하는 중요한 클래스이다.
- 스프링 부트의 장점 중 하나는 자동 구성으로 기존의 복합한 구성, 설정을 제거하고 최소한의 설정으로 바로 실행 가능한 애플리케이션을 만들어 준다는 점이다.

### @SpringBootApplication

이 어노테이션은 스프링 부트의 핵심 어노테이션으로 세 개의 스프링 부트 어노테이션으로 구성 되어 있다.

- @EnableAutoConfiguration

  - 이 어노테이션을 사용하기만 하면 스프링의 다양한 설정이 자동으로 완료된다.( 어떤이는 마법의 어노테이션이라고 극찬하기도...)

  

- @ComponentScan

  - 기존의 스프링은 빈(Bean) 클래스를 사용하기 위해서 XML에 일일이 빈을 선언해 줘야 사용할 수 있었다.
  - but, 이 어노테이션은 Component 검색 기능을 활성화해서 자동으로 컴포넌트 클래스를 검색하고(@Component가 있는 클래스를 탐색),  
  - 검색된 컴포넌트 및 빈 클래스를 스프링 애플리케이션 컨텍스트에 등록하는 역활을 한다. 

  

- @Configuration

  - @SpringBootApplication 어노테이션은 엄밀히 말해 @Configuration이라는 어노테이션을 포함하고 있지 않다.
  - 대신에, @SpringBootConfiguration이라는 어노테이션이 포함되어있고, 이 어노테이션에 @Configuration이 포함되어 있다.
  - @Configuration이 붙은 자바 클래스는 자바 기반 설정 파일임을 의미한다.
    - 스프링 3.x 버전 까지는 자바 기반의 설정이 불가능하였다.
    - 따라서 XML 기반의 설정에 오랜 시간을 투자해야 했다.





# 3장 (스프링 프레임워크 이해하기)



## 스프링 프레임워크란?

| 프로젝트 이름     | 설명                                                         |
| ----------------- | :----------------------------------------------------------- |
| 스프링 프레임워크 | 자바 기반의 애플리케이션을 개발하는 데 기반이 되는 프레임워크. 스프링의 핵심은 애플리케이션의 기반을 제공함으로써 개발자들은 비즈니스 로직의 개발에만 집중할 수 있게 하는데 있다. |
| 스프링 부트       | 스프링 프레임워크를 기반으로 바로 실행 가능한 애플리케이션을 쉽게 만들도록 도와준다. 대부분의 복잡한 스프링 관련 설정을 자동으로 처리, 개발자는 최소한의 설정만 하면 된다. |
| 스프링 데이터     | 스프링 애플리케이션에서 다양한 데이터베이스, JPA 등의 데이터 접근 기술을 쉽게 사용할 수 있도록 도와준다. 스프링 데이터는 하나의 상위 프로젝트로 세부적으로 데이터베이스 종류에 따라서 수많은 하위 프로젝트가 존재 |
| 스프링 시큐리티   | 자바 애플리케이션에 인증(Authentication) 및 권한(Authorization)에 특화된 프레임워크 |
| 스프링 소셜       | 페이스북, 트위터, 링크드인과 같은 소셜 서비스 API와 쉽게 연동할 수 있게 도와준다. |

> 설명 중에서 몇몇 단어들이 좀 어색하거나 이상하다.  추후에 다시 바꾸도록하자....



## MVC 패턴 및 스프링 MVC

- MVC

  - Model  =>  애플리케이션의 정보, 즉 데이터를 의미

  - View   =>  사용자 인터페이스, 즉 사용자가 보고 사용하는 화면 등을 의미

  - Controller   =>  모델과 뷰의 중계자 역활. 사용자의 요청을 파악하고 그에 맞는 결과를 사용자에게 돌려준다.

    

- MVC 패턴도 모델1과 모델 2가 있지만 최근에는 대부분 모델 2를 사용

  

- MVC 패턴을 사용하면 사용자 인터페이스와 비즈니스 로직을 분리하여 개발 가능

  - 서로의 영향을 최소화



### 스프링 웹 MVC의 구조

각 컨트롤러에 필요한 코드가 작성되기 때문에 어쩔 수 없이 일부 코드가 중복되는 등의 문제가 있다. 이러한 문제를 해결하기 위한 방식이  '프론트 컨트롤러' 방식이다.

프론트 컨트롤러는 컨트롤러 앞에 존재하는 컨트롤러로 모든 흐름의 제어를 담당한다.

스프링 웹 MVC의 디스패처 서블릿은 다음과 같다.

> ​	[마크다운 그래프, 차트 사용법](http://morethanair.com/archives/404) ~~차트로 할려고 했으나 귀찮아서 그림으로 대체~~

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fcf4UuH%2FbtqwzzFq6qt%2FvW3tGhrR4UzTTyjCgWL3J0%2Fimg.jpg)



스프링 MVC에서는 디스패처 서블릿이 프론트 컨트롤러의 역활을 한다. 여기서 중요한 단어가 나오는데, 'delegate(위임하다)'이다. 

전체 로직 중 일부를 컨트롤러에 위임하고 앞의 ==프론트 컨트롤러는 흐름의 제어를 담당==한다. 또한, 컨트롤러에서는 결과값의 반환을 프론트 컨트롤러에 위임한다. 

이 경우 ==사용자 요청을 처리할 수 있는 컨트롤러의 호출은 프론트 컨트롤러가 담당==하고 개발자는 요청에 대한 적절한 처리만 하면 되므로 작성할 코드가 적어진다.



### 일반적으로 사용하는 스프링 MVC의 구조

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fk.kakaocdn.net%2Fdn%2Fd294ju%2Fbtqwzy0U9uM%2FiCTO7DkDcUefRHWLuIyBH0%2Fimg.jpg)

| 영역       | 역할                                                         |
| ---------- | ------------------------------------------------------------ |
| View       | 사용자가 보는 화면 또는 결과를 의미한다.                     |
| Controller | 사용자가 웹브라우저를 통해서 어떠한 요청을 하면 그 요청을 처리할 컨트롤러를 호출하게 된다. 컨트롤러는 사용자의 요청을 처리하기 위한 비즈니스 로직을 호출하고 그 결과값을 사용자에게 전달해 주는 역활을 한다. |
| Service    | 사용자의 요청을 처리하기 위한 비즈니스 로직이 수행된다. 일반적으로 서비스 영역은 서비스 인테페이스와 이 인터페이스의 구현체로 나뉜다. |
| DAO        | Data Access Object의 약자로 데이터베이스에 접속해서 비즈니스 로직 실행에 필요한 쿼리를 호출한다. |
| DB         | 데이터베이스를 의미한다. 데이터베이스에는 애플리케이션에서 발생한 모든 정보가 저장되어 있다. |





## MyBatis

마이바티스(MyBatis)는 쿼리 기반 웹 앱을 개발할 때 가장 많이 사용되는 SQL 매퍼(Mapper) 프레임워크이다.

MyBatis를  사용하지 않고  직접 JDBC를 이용할 경우 개발자가 반복적으로 작성해야 할 코드가 많고, 서비스 로직 코드와 쿼리를 분리하기 어렵다. 또한 커넥션 풀의 설정 등 개발자가 신경 써야 할 부분이 많다.

>MyBatis 홈페이지의 설명
>
>MyBatis는 개발자가 지정한 SQL, 지장프로시저 그리고 몇 가지 고급 매핑을 지원하는 퍼시스턴스 프레임워크이다. MyBatis는 JDBC로 처리하는 상당부분의 코드와 파라미터 설정 및 결과 매핑을 대신해 준다. MyBatis는 데이터베이스 레코드에 원시타입과 Map 인터페이스 그리고 자바 POJO를  설정해서 매핑하기 위해 XML과 어노테이션을 사용할 수 있다.



### MyBatis란?

MyBatis는 기존의 JDBC를 이용하여 개발하는 방식에 비해 개발자의 부담을 덜어 주고 생산성을 향상시켜 준다. 

JDBC를 이용하여 프로그래밍을 하는 방식은 클래스나 JSP와 같은 코드 안에 SQL문을 작성하는 방식이었다. 따라서 SQL의 변경 등이 발생할 경우 프로그램을 수정해야 하기 때문에 유연성이 좋지 못하고 여러가지 코드가  섞여 있어 가독성이 좋지 못했다.

MyBatis에서는 SQL을 XML 파일에 작성하기 때문에 , SQL의 변환이 자유롭고 가독성도 좋다는 장점이 있다.







# 4장

## Lombok 이란?

롬복은 자바 클래스를 만들 때 흔히 만드는 코드들(getter, settter)은 어노테이션을 이용해서 자동으로 만들어 주는 라이브러리이다. 흔히 DTO같은 모델에서 항상 만들게 되는 getter, setter와 자주 만들게 되는 toString, equals, hashCode와 같은 코드들을 자동으로 만들어 준다.

>DTO(VO)와 맵(Map)
>
>데이터 전송 객체로 DTO 또는 VO(Value Object, DTO와 VO는 다른 개념이지만 많은 사람들이 동일한 의미로 잘못 사용하고 있다.)와 Map 중 어떤 것을 사용해야 하는지에 대한 논쟁은 오래전부터 이어져 왔다. 인터넷에서 "dto vs. map"으로 검색하면 이와 관련된 논쟁을 국내외를 막론하고 심심치 않게 찾아 볼 수 있다. 각각의 방식이 모두 장점과 단점을 가지고 있기 때문에 한때는 프로젝트마다 각자 편한 방식을 사용했지만, 요즘에는 맵은 잘 사용하지 않는다. 



## Service 인터페이스와 ServiceImpl 클래스를 분리

인터페이스를 실제로 구현하는 클래스와 인터페이스로 분리할 경우 여러 가지 장점이 있다.

- 느슨한 결함(loose coupling)을 유지하여 각 기능 간의 의존관계를 최소화한다.
- 의존관계의 최소화로 인해 기능의 변화에도 최소한의 수정으로 개발할 수 있는 유연함을 가질 수 있다.
- 모듈화를 통해 어디서든 사용할 수 있도록 하여 재사용성을 높인다.
- 스프링의 Ioc/DI  (Inversion of Control  /   Dependency Injection) 기능을 이용한 빈 관리 기능을 사용할 수 있다.





# 5장 스프링의 다양한 기능



## Logback 사용하기 (slf4j)

- 시스템의 로그는 프로그램을 개발 및 유지보수, 에러확인 등 애플리케이션 전반에 걸쳐 사용된다.

  

> ### Logback이란?
>
> 가장 많이 사용되던 로그 라이브러리는 Log4j였다. 지금은 개발이 종료되기는 했지만 Log4j는 자바의 예외를 처리하기 위해 시작된 프로젝트 였다.
>
> Log4j의 성공에 힘입어 Log4j의 개발자는 로거에 대해 좀 더 깊은 프로젝트를 시작했고, 그 결과 Log4j를 토대로 Logback을 만들게 되었다.



### Logback의 장점

-  오랫동안 널리 사용되고 검증된 Log4j를 기반으로 다시 작성되었다.

- Log4j와 비교해서 성능은 10배 정도 빠르고 메모리 사용량도 적다.

- Log4j부터 진행한 테스트 경험을 토대로 더욱 광범위한 테스트를 통해 검증 되었다.

- 로그 설정이 변경될 경우 서버를 재시작하지 않더라도 바로 반영된다. Log4j와 같은 로그 라이브러리는 로그 설정을 반경할 경우 서버를 재시작해야 반영되었다. 그렇지만 Logback은 로그 설정이 변경될 경우 내부에 설정 변화를 감지하는 별도의 스레드가 존재하기 때문에  서버의 재시작 없이 바로 반영된다. 

  이러한 스레드는 서버에 초당 100만 번이 넘는 요청을 하더라도 애플리케이션의 성능에 큰 영향을 끼치지 않는다.



이러한 장점들을 가진 Logbak은 로깅 구현체 중 하나로 ==slf4j (Simple Logging Facade for Java)==를 함께 사용한다. slf4j는 자바의 다양한 로그 모듈들의 추상체라고 할 수 있다. 

엄밀히 말하면 자바의 인터페이스와 비슷한 역활을 한다고 할 수 있다. slf4j의 API를 이용할 경우 실제 로깅을 담당하는 로깅 구현체의 종류와 상관없이 일관된 로그 코드를 작성할 수 있다.





## 인터셉터

스프링의 인터셉터는 어떠한 URI를 호출했을 때 해당 요청의 ==컨트롤러가 처리되기 전 또는 후에 작업을 하기 위해서 사용==된다.

이러한 역할은 필터와 인터셉터로 수행할 수 있다.  기능적인 면에서는 필터와 인터셉터가 상당히 비슷해 보인다. 필터로 할 수 있는 일은 인터셉터로 할 수 있고, 반대로 인터셉터로 할 수 있는 일은 필터로도 할 수 있다.



### 인터셉터와 필터의 차이점



- 필터는 디스패쳐 서블릿 앞 단에서 동작하지만 인터셉터는 디스패처 서블릿에서 핸들러 컨트롤러로 가기 전에 동작한다.
- 필터는 J2EE 표준 스펙에 있는 서블릿의 기능 중 일부이지만 인터셉터는 스프링 프레임워크에서 제공되는 기능이다. 따라서 필터와 달리 인터셉터에서는 스프링 빈을 사용할 수 있다.



정확히 언제 필터와 인터셉터를 사용하는지에 대해서는 여러 가지 의견이 있다.  일반적으로 

- 문자열 인코딩과 같은 웹 전반에서 사용되는 기능은 필터로 구현
- 클라이언트의 요청과 관련이 있는 여러 가지 처리 (예를 들어 로그인이나, 인증, 권한 등)는 인터셉터로 처리한다.



### HandlerInterceptorAdapter로 인터셉터 구현하기

스프링에서는 인터셉터는 HandlerInterceptorAdapter 클래스를 상속받아서 구현할 수 있다.

HandlerInterceptorAdapter는 다음의 3 가지 메서드를 제공한다.

| 메서드          | 역활                                               |
| --------------- | -------------------------------------------------- |
| preHandle       | 컨트롤러 실행 전에 수행된다.                       |
| postHandle      | 컨트롤러 수행 후 결과를 뷰로 보내기 전에 수행된다. |
| afterCompletion | 뷰의 작업까지 완료된 후 수행된다.                  |

인터셉터로 원하는 기능을 만들려면 필요한 메서드를 사용해서 인터셉터를 등록하면 된다.







## AOP

스프링 프레임워크를 이야기할 때 빠지지 않고 등장하는 단어 중 하나가 AOP이다. AOP는 IoC/DI와 함께 스프링 프레임워크에서 중요한 내용이다. 

AOP는 Aspect Oriented Programming의 약자로 관점지향 프로그래밍이라고 한다. 



### AOP란?

스프링의 여러 가지 장점 및 특징을 이야기할 때 빠지지 않고 등장하는 것이 바로 AOP이다. AOP를 OOP(Object Oriented Programming; 객체지향 프로그래밍)를 대체하는 개념으로 오해하는 경우도 있다. 사실 AOP는 OOP를 더욱 OOP 답게 사용하도록 도와주는 개념이다.

> OOP의 개념
>
> 현대의 프로그래밍은 대부분 객체지향이라는 개념을 가지고 구현된다.  객체지향이란 관심사가 같은 기능과 데이터를 모아서 재사용이 가능한 객체로 캡슐화를 하는 것을 의미한다. 이러한 클래스를 만들어 여러곳에서 반복적으로 재사용되면서 생산성이 높아졌다.

AOP는 애플리케이션 전반에서 사용되는 기능을 여러 코드에 쉽게 적용할 수 있도록 한다. 예를 들어 로그, 권한 체크, 인증, 예외처리 등은 애플리케이션의 대부분에 적용되어야 하는 기능이다.

기존의 프로그래밍에서는 공톡적으로 사용하는 기능을 하나의 클래스로 만들어 놓고, 해당 기능이 필요한 모든 부분에서 클래스를 생성하고 필요한 메서드를 호출해야만 했다. 즉, 필요한 모든 부분에 코드를 직접 공통 기능을 추가해야 했다.



AOP는 이러한 문제를 관점(OR 관심)이라는 개념을 통해서 해결한다.

부가 기능의 관점에서는 핵심 로직이 어떤 역활을 하는지 몰라도 된다. 단지 부가 기능이 적용될 시점, 즉 핵심 로직의 시작이나 종료 시점에 그곳에서 필요한 부가 기능이 적용되기만 하면 된다.

OOP와 비교해서 권한, 로깅, 트랜젝션과 같은 부가 기능이 비즈니스 로직에 직접적으로 삽입된 것이 아니라 외부에 있는다. 각각의 부가 기능의 입장에서는 해당 기능이 들어갈 시점만 확인하면 된다.

비즈니스 로직은 신경쓰지 않아도 된다. 비즈니스 로직이 몇 개가 추가 되더라도 컨트롤러나 서비스와 같은 영역의 실행시점에만 삽입되면 된다. 비즈니스 로직의 관점에서는 핵심적인 로직만 신경 쓰고 부가적인 기능을 신경 쓰지 않아도 된다. 

반대로 부가 기능의 관점에서는 각각의 가로 영역(핵심 로직)에서 공통된 부분을 잘라내고 그 사이에 삽입된다.



### OOP를 더욱 OOP적으로 만들어주는 AOP

AOP는 결국 공통된 기능을 재사용하는 것이다. 물론 OOP도 공통된 기능을 하나의 객체로 만들고 이를 다른 객체로 만들고 이를 다른 객체에서 호출하는 식으로 구현된다.

하지만 공통 기능을 구현하기 위해 다시 다른 객체의 기능을 필요하다거나,  객체에서 다른 객체를 계속 호출해야 하는 등 객체 간 종속성이 강한 경우가 있다.  

> 이러한 경우 모듈화를 깔끔하게 하기가 어렵다.



AOP를 이용하면 다른 객체의 호출과 상관없이 각각의 기능에만 집중해서 모듈로 만들 수 있다. 필요한  지점에서 기능을 직접 삽입하면 된다. 즉, AOP는 비즈니스 로직을 구현한 코드에서 공통 기능 코드르 직접 호출하지 않는다.



즉, AOP는 비즈니스 로직을 구현한 코드에서 공통 기능 코드를 직접 호출하지 않는다. AOP를 적용하면 공통 기능과 비즈니스 기능을 따로 개발한 후 컴파일하거나 컴파일된 클래스를 로딩하는 시점 등에 AOP가 적용되어 비즈니스 로직 코드 사이에 공통 기능 코드가 삽입된다.

> 기존의 프로그래밍에서는 각 객체별로 적용했던 기능을 AOP에서는 각각의 관심별로 외부에서 추가하는 것이 핵심이다.



- 용어 정리

  | 용어                  | 의미                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | 관점(Aspect)          | 공통적으로 적용될 기능을 의미한다. 횡단 관심사의 기능이라고도 할 수 있으며 한 개 이상의 포인트컷과 어드바이스의 조합으로 만들어 진다. |
  | 어드바이스(Advice)    | 관점의 구현체로 조인 포인트에 삽입되어 동작하는 것을 의미한다. 스프링에서 사용하는 어드바이스는 동작하는 시점에 따라 다섯 종류로 구분된다. |
  | 조인포인트(Joinpoint) | 어드바이스를 적용하는 지점을 의미한다. 스프링 프레임워크에서 조인포인트는 항상 메서드 실행 단계만 가능하다. |
  | 포인트컷(Pointcut)    | 어드바이스를 적용할 조인포인트를 선별하는 과정이나 그 기능을 정의한 모듈을 의미한다. 정규식표현이나 AspectJ의 문법을 이용해서 어떤 조인포인트를 사용할 것인지를 결정한다. |
  | 타깃(Target)          | 어드바이스를 받을 대상을 의미한다.                           |
  | 위빙(Weaving)         | 어드바이스를 적용하는 것을 의미한다. 즉, 공통 코드를 원하는 대상에 삽입하는 것을 뜻한다. |





### AOP의 주요 개념



- 어드바이스

  관점의 구현체로 조인 포인트에 삽입되어 동작하는 것을 의미한다. 스프링에서 사용하는 어드바이스는 동작하는 시점에 따라 다섯 종류로 구분된다.



| 종류                   | 어노테이션      | 설명                                                         |
| ---------------------- | --------------- | ------------------------------------------------------------ |
| Before Advice          | @Before         | 대상 메서드가 실행되기 전에 적요할 어드바이스를 정의한다.    |
| After returning Advice | @AfterReturning | 대상 메서드가 성공적으로 실행되고 결과값을 반환한 후 적용할 어드바이스를 정의한다. |
| After throwing Advice  | @AfterThrowing  | 대상 메서드에서 예외가 발생했을 때 적용할 어드바이스를 정의한다. try/catch 문의 catch와 비슷한 역할을 한다. |
| After Advice           | @After          | 대상 메서드의 정상적인 수행 여부와 상관없이 무조건 실행되는 어드바이스를 정의한다. 즉, 예외가 발생하더라도 실행되기 때문에 자바의 finally와 비슷한 역할을 한다. |
| Around Advice          | @Around         | 대상 메서드의 호출 전후, 예외 발생 등 모든 시점에 적용할 수 있는 어드바이스를 정의한다. 가장 범용적으로 사용할 수 있는 어드바이스이다. |

- 포인트컷

  어드바이스를 적용할 조인포인트를 선별하는 과정이나 그 기능을 정의한 모듈을 의미한다. 정규식표현이나 AspectJ의 문법을 이용해서 어떤 조인포인트를 사용할 것인지를 결정한다.

  포인트컷을 표현할 수 있는 명시자에는 여러 종류가 있지만 일반적으로 가장 많이 사용되는 명시자는 execution이다. 여서는 execution, within, bean 명시자에 대해 설명하겠다.

  - execution
  
    가장 대표적이고 강력한 지시자로 접근 제어자, 리턴 타입, 타입 패턴, 메서드, 파라미터 타입, 예외 타입 등을 조합해서 가장 정교한 포인트컷을 만들 수 있다.
  
    execution을 이용해서 포인트컷 표현식을 설정할 때 사용하는 표현이 있다. 
  
    - *는 모든 값이라는 의미를 표현.
  
      예를 들어 메서드 이름을 select *로 표현하면 select로 시작하는 모든 메서드가 선택된다.
  
    - ..은 0개 이상이라는 의미를 표현.
  
      0개 이상은 파라미터, 메서드, 패키지 등 모든 것을 의미한다. 패키지 구조를 표현하면 하위의 모든 패키지를 의미하고 파라미터를 표현할 때에는 파라미터 개수와 관계없이 모든 파라미터를 의미한다.
  
  - within
  
    특정 타입에 속하는 메서드를 포인트컷으로 설정한다. 
  
    ```java
    //within 사용 예
    within(board.service.boardServiceImpl) // 1
    within(board.service.*ServiceImpl) // 2
    ```
  
    1. board.service 패키지 밑에 있는 boardServiceImpl 클래스의 메서드가 호출될 때
    2. board.service 패키지 밑에 있는 ServiceImpl이라는 이름으로 끝나는 매서드가 호출될 때
  
  - bean
  
    스프링의 빈 이름의 패턴으로 포인트컷을 설정한다.  
  
    ```java
    //bean 사용 예
    bean(boardServiceImpl) //1
    bean(*ServiceImpl) //2
    ```
  
    1. boardServiceImpl이라는 이름을 가진 빈의 메서드가 호출될 때
    2. ServiceImpl이라는 이름으로 끝나는 빈의 메서드가 호출될 때





## 트랜젝션

스프링에서 트랜젝션을 처리하는 방식은  아래와 같음

- XML
- 어노테이션 이용
- AOP 이용



### 트랜젝션이란?

트랜젝션이란 데이터베이스의 상태를 변화시킬 때 더 이상 분리할 수 없는 작업의 단위를 의미한다. 즉, 하나의 트랜젝션에서 일련의 작업이 처리되어야 한다. 트랜잭션을 설명할 때 빠지지 않는 것이 ACID 속성이다.

| ACID                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| 원자성(Atomicity)   | 트랜잭션은 하나 이상의 관련된 동작을 하나의 작업 단위로 처리한다. 트랜젝션이 처리하는 하나의 작업 단위는 그 결과가 성공 또는 실패할 경우 관련된 동작은 모두 동일한 결과가 나온다. 작업 중 하나라도 실패한다면 관련된 트랜잭션 내에서 먼저 처리한 동작들도 모두 처음 상태로 돌아간다. |
| 일관성(Consistency) | 트랜잭션이 성공적으로 처리되면 데이터베이스의 관련된 모든 데이터는 일관성을 유지해야 한다. |
| 고립성(Isolation)   | 트랜잭션은 독립적으로 처리되며, 처리되는 중간에 외부에서의 간섭은 없어야 한다.  서로 다른 트랜잭션이 동일한 데이터에 동시에 접근할 경우 적절한 동시 접근 제어를 해야한다. |
| 지속성(Durability)  | 트랜잭션이 성공적으로 처리되면 그 결과는 지속적으로 유지되어야 한다. |



이 속성 중에서 가장 트랜잭션을 잘 표현한 것은 원자성이다. 즉, 성공하려면 다 성공해야하고 하나라도 실패하면 모두다 실패로 한다는 것이다. 실패한 경우 전체 과정을 모두 취소하고 트랜잭션이 시작하기 전의 상태로 되돌린다. 이를 ==롤백(Rollback)==이라고 한다.







# 6장 파일 업로드와 다운로드











